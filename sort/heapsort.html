<!DOCTYPE html><html lang="en"><head><title>sort/heapsort</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="sort/heapsort"><meta name="groc-project-path" content="js/src/sort/heapsort.js"><meta name="groc-github-url" content="https://github.com/aureooms/js-selection"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/aureooms/js-selection/blob/master/js/src/sort/heapsort.js">js/src/sort/heapsort.js</a></div></div><div id="document"><div class="segment"></div><div class="segment"><div class="comments "><div class="wrapper"><p>Template for a raw implementation of heapsort.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">var</span> __heapsort__ = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> arity </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Note that here we reverse the order of the
comparison operator since when we extract
values from the heap they can only be stored
at the end of the array. We thus build a max-heap
and then pop elements from it until it is empty.</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">var</span> heapsort = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> compare, a, i, j </span>) </span>{

		<span class="hljs-keyword">var</span> k, y, t, current, parent, candidate, tmp;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>construct the max-heap</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> ( k = i + <span class="hljs-number">1</span> ; k &lt; j ; ++k ) {

			current = k - i;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>while we are not the root</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">while</span> ( current !== <span class="hljs-number">0</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>address of the parent in a zero-based
d-ary heap</p></div></div><div class="code"><div class="wrapper">				parent = i + ( ( current - <span class="hljs-number">1</span> ) / arity | <span class="hljs-number">0</span> );
				current += i;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if current value is smaller than its parent
then we are done</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( compare( a[current], a[parent] ) &lt;= <span class="hljs-number">0</span> ) {
					<span class="hljs-keyword">break</span>;
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>otherwise
swap with parent</p></div></div><div class="code"><div class="wrapper">				tmp = a[current];
				a[current] = a[parent];
				a[parent] = tmp;

				current = parent - i;

			}

		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>exhaust the max-heap</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">for</span> ( --k ; k &gt; i ; --k ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>put max element at the end of the array
and percolate new max element down
the heap</p></div></div><div class="code"><div class="wrapper">			tmp = a[k];
			a[k] = a[i];
			a[i] = tmp;

			current = <span class="hljs-number">0</span>;

			<span class="hljs-keyword">while</span> ( <span class="hljs-literal">true</span> ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>address of the first child in a zero-based
d-ary heap</p></div></div><div class="code"><div class="wrapper">				candidate = i + arity * current + <span class="hljs-number">1</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if current node has no children
then we are done</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( candidate &gt;= k ) {
					<span class="hljs-keyword">break</span>;
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>search for greatest child</p></div></div><div class="code"><div class="wrapper">				t = <span class="hljs-built_in">Math</span>.min( candidate + arity, k );

				y = candidate;

				<span class="hljs-keyword">for</span> ( ++y ; y &lt; t ; ++y ) {

					<span class="hljs-keyword">if</span> ( compare( a[y], a[candidate] ) &gt; <span class="hljs-number">0</span> ) {
						candidate = y;
					}

				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if current value is greater than its greatest
child then we are done</p></div></div><div class="code"><div class="wrapper">				current += i;

				<span class="hljs-keyword">if</span> ( compare( a[current], a[candidate] ) &gt;= <span class="hljs-number">0</span> ) {
					<span class="hljs-keyword">break</span>;
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>otherwise
swap with greatest child</p></div></div><div class="code"><div class="wrapper">				tmp = a[current];
				a[current] = a[candidate];
				a[candidate] = tmp;

				current = candidate - i;

			}

		}

	};

	<span class="hljs-keyword">return</span> heapsort;

};

exports.__heapsort__ = __heapsort__;</div></div></div></div></body></html>